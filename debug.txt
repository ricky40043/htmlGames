✅ 1.創建房間有時跳轉，有時沒有跳轉，好像是重開幾次會出現 - 已修正
✅ 2.加入房間有時後會看到主板已加入，但加入的人卻沒有跳轉 - 已修正
✅ 3.有時加入房間失敗，卻沒有跳訊息，主板沒有看到那個人 - 已修正
✅ 4.開始遊戲，所有玩家沒有跳轉到答題畫面 - 已修正

✅ 5.房間創建完，第二次就無法創建 - 已修正（添加頁面離開清理邏輯）
✅ 6.答題時間沒有倒數，全部人都沒有倒數 - 已修正（實現後端計時器廣播）
✅ 7.主板也沒有登記到大家每一次答題的分數 - 已修正（實現「2種人」計分邏輯）
✅ 8.玩家每次答題結束，沒有跳轉到下一個問題，停留在第一題 - 已修正（實現自動下一題）

✅ 9.編譯錯誤 - 已修正（添加缺失的 models 導入和 Room.Answers 字段）

✅ 10.WebSocket 消息解析錯誤 - 已修正（修正後端 writePump 的消息發送邏輯）
✅ 11.QR Code 產生失敗 - 已修正（修正後端房間 URL 生成和前端數據格式）

✅ 12.換到下一題時其他玩家顯示「準備題目中...」- 已修正（優化 handleNewQuestion 事件處理）
✅ 13.答題完沒有顯示分數 - 已修正（實現 SCORES_UPDATE 事件和分數顯示邏輯，5秒後自動下一題）

✅ 14.到第二題還是準備題目中... - 已修正（修正 Question 類型定義，移除不需要的字段，改進題目設置邏輯）
✅ 15.QR Code 還是產生失敗 - 已修復（修正 canvas 元素創建方式）
🔧 16.第二題無法顯示 - 已修復（修正前端題目索引設置順序，添加詳細驗證日誌）
🔧 17.第一題沒有記錄到主角以外的的作答 - 已修復（添加玩家答題進度顯示）
✅ 18.主板第二題開始時倒數計時變成2個同時進行 - 已修復（只允許主持人啟動計時器）

【Debug Log 視窗說明】
這是一個自訂的前端調試日誌系統，不需要任何外部套件，使用純 JavaScript 實現。

【技術實現】
- 檔案位置：`kahoot-game/frontend/debug-log.js`
- 實現方式：純 JavaScript + CSS，無需任何套件
- 功能特色：
  * 實時日誌顯示
  * 分類過濾 (INFO, WARN, ERROR, DEBUG)
  * 日誌匯出功能
  * 自動滾動到最新日誌
  * 可隱藏/顯示的浮動視窗

【前端整合】
- 在 `index.html` 中引入：`<script src="/debug-log.js"></script>`
- 全域物件：`window.debugLogger`
- 類型定義：`kahoot-game/frontend/src/types/global.d.ts`

【使用方法】
```javascript
// 在前端程式碼中使用
window.debugLogger.info('分類', '訊息', 數據物件)
window.debugLogger.warn('分類', '警告訊息', 數據物件)
window.debugLogger.error('分類', '錯誤訊息', 數據物件)
```

【測試指南】
1. 打開前端：http://localhost:5173/
2. 頁面右下角會自動出現黑色的 Debug Log 視窗
3. 進行正常的遊戲測試
4. 觀察 Debug Log 視窗中的即時日誌
5. 點擊 "Export" 按鈕匯出完整日誌檔案
6. 點擊 "Clear" 清除日誌
7. 點擊 "Hide" 隱藏視窗

【關鍵日誌分類】
- QR_CODE: QR Code 生成相關日誌
- NEW_QUESTION: 新題目接收和處理日誌  
- SCORES_UPDATE: 分數更新和答案記錄日誌
- TIMER_UPDATE: 計時器事件日誌
- WEBSOCKET: WebSocket 通訊日誌

【測試重點】
- 問題15: 查看 QR_CODE 分類的錯誤日誌
- 問題16: 查看 NEW_QUESTION 分類，確認第二題的數據
- 問題17: 查看 SCORES_UPDATE 分類，確認玩家數量統計
- 問題18: 查看 TIMER_UPDATE 分類，查找重複計時器警告 
✅ 19.玩完一次遊戲就無法開創第二次房間 - 已修復（修正房間創建流程 + joinUrl修復 + 用戶操作觸發清理）
✅ 20.玩家列表顯示為空 - 已修復（修正前端 PLAYER_JOINED 事件處理邏輯）
✅ 21.第二次創建房間後無法建立 WebSocket 連接 - 已修復（強制重新建立 WebSocket 連接 + 修正 shouldReconnect 邏輯）
🔍 22.第二次遊戲開始後卡住無法進行 - 調試中（添加 GAME_STARTED 廣播日誌以診斷問題）

【問題19修復詳情】
- 修復原因1：遊戲結束後沒有清理 WebSocket 連接和遊戲狀態
- 修復原因2：房間創建流程錯誤，直接使用 WebSocket 而非先用 HTTP API
- 修復原因3：joinUrl 硬編碼錯誤，導致玩家無法正確加入房間
- 修復方案：
  * 【流程修正】修改 CreateRoomView 使用正確的房間創建流程：
    - 先通過 HTTP API 創建房間（apiService.createRoom）
    - 再建立 WebSocket 連接
    - 最後通過 WebSocket 加入房間作為主持人
  * 【joinUrl修復】修改後端 room_handler.go 動態生成正確的 joinUrl：
    - 舊方式：硬編碼 "http://localhost:5173/join/" + room.ID
    - 新方式：動態獲取請求的 scheme 和 host，自動適配環境
    - 結果：joinUrl 現在正確生成為前端地址，QR Code 也使用完整 URL
  * 【清理系統】在 ResultsView 的"再來一局"和"返回主頁"按鈕中添加手動清理
  * 【詳細日誌】添加完整的房間創建過程日誌記錄
- 房間創建新流程：
  1. HTTP API 創建房間 → 2. 設置房間信息到 store → 3. 建立 WebSocket 連接 → 4. 加入房間作為主持人 → 5. 跳轉到大廳
- 清理觸發時機：
  * 用戶點擊"🎮 再來一局"按鈕
  * 用戶點擊"🏠 返回主頁"按鈕
  * 清理後 500ms 才進行路由跳轉，確保清理完成
- 清理內容：
  * WebSocket 連接斷開
  * 遊戲狀態重置（gameStore.resetGame）
  * UI 消息清除（uiStore.clearAllMessages）
  * 計時器事件記錄清除
  * 重連計數重置

【問題20修復詳情】
- 修復原因：前端 handlePlayerJoined 函數邏輯錯誤，沒有正確處理玩家列表更新
- 問題分析：
  * 後端正確發送包含完整玩家列表的 PLAYER_JOINED 事件
  * 前端假設 data.players 存在但沒有正確處理數組更新
  * 玩家加入時前端沒有清空舊列表，導致重複或遺漏
- 修復方案：
  * 【詳細日誌】添加完整的 PLAYER_JOINED 事件日誌記錄
  * 【列表清理】在更新玩家列表前先清空現有列表，避免重複
  * 【邏輯優化】改進玩家列表處理邏輯，支持完整列表和單個玩家更新
  * 【錯誤處理】添加數組檢查和異常情況處理
- 修復效果：玩家加入房間後，玩家列表正確顯示所有玩家信息

【問題21修復詳情】
- 修復原因：cleanupAfterGame 函數中 shouldReconnect 被設為 false 且沒有重置，導致後續 WebSocket 無法重新連接
- 問題分析：
  * 第一次遊戲結束後，cleanupAfterGame 執行並設置 shouldReconnect = false
  * 第二次創建房間時，雖然調用 connect() 但 shouldReconnect 仍為 false
  * WebSocket 連接失敗時不會自動重連，導致加入房間失敗
  * 後端成功創建房間，但前端無法建立 WebSocket 連接
  * isConnected 狀態可能存在不一致，導致條件判斷錯誤
- 修復方案：
  * 【邏輯修正】在 cleanupAfterGame 最後恢復 shouldReconnect = true
  * 【強制重連】在 CreateRoomView 中強制斷開現有連接並重新建立
  * 【狀態檢查】詳細記錄連接狀態和重連過程
  * 【時序優化】等待 500ms 確保舊連接完全關閉再建立新連接
  * 【超時延長】將連接等待時間從 3秒 延長到 5秒
- 修復效果：第二次及後續遊戲都能正常建立 WebSocket 連接和加入房間

【問題22修復詳情】
- 修復原因：第二次遊戲時房間的題目數組為空，sendFirstQuestion 直接返回無法發送題目
- 問題分析：
  * 第一次遊戲：HTTP API 創建房間時載入題目 (CreateRoom → GetRandomQuestions)
  * 第二次遊戲：自動化測試重用相同房間ID，但房間對象可能沒有題目
  * sendFirstQuestion 檢查 len(room.Questions) == 0 時直接返回
  * 導致第二次遊戲發送 GAME_STARTED 但沒有 NEW_QUESTION
- 修復方案：
  * 【動態檢查】在 sendFirstQuestion 中檢查題目數量
  * 【自動重載】如果沒有題目，自動調用 services.GetRandomQuestions 重新載入
  * 【詳細日誌】記錄題目檢查和重載過程，便於診斷
  * 【錯誤處理】如果重載失敗，發送錯誤訊息給前端
- 修復效果：第二次及後續遊戲都能正常載入題目並進行完整遊戲流程
